{
  "compiler": {
    "version": "0.8.19"
  },
  "language": "Solidity",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ]
      }
    }
  },
  "sources": {
    "PropertyRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title PropertyRegistry\n * @dev Smart contract for managing land registry and property transfers\n */\ncontract PropertyRegistry {\n    \n    // Enums\n    enum UserRole { None, Seller, Buyer, Registrar, Municipal, Broker }\n    enum TransferStatus { \n        Initiated,      // Seller initiated transfer\n        BrokerVerified, // Broker verified transaction\n        RegistrarVerified, // Registrar verified documents\n        MunicipalApproved, // Municipal approved transfer\n        BuyerAccepted,  // Buyer accepted transfer\n        Completed,      // Transfer completed\n        Cancelled       // Transfer cancelled\n    }\n    \n    // Structs\n    struct Property {\n        uint256 propertyId;\n        address currentOwner;\n        string propertyAddress;\n        string propertyType; // Residential, Commercial, Agricultural, etc.\n        uint256 area; // in square feet/meters\n        string ipfsHash; // IPFS hash for property documents\n        uint256 registrationDate;\n        bool isActive;\n    }\n    \n    struct TransferRequest {\n        uint256 transferId;\n        uint256 propertyId;\n        address seller;\n        address buyer;\n        uint256 price;\n        string documentsHash; // IPFS hash for transfer documents\n        TransferStatus status;\n        address broker;\n        bool brokerVerified;\n        bool registrarVerified;\n        bool municipalApproved;\n        bool buyerAccepted;\n        uint256 createdAt;\n        uint256 completedAt;\n    }\n    \n    struct OwnershipHistory {\n        address owner;\n        uint256 transferId;\n        uint256 timestamp;\n        string ipfsHash;\n    }\n    \n    // State Variables\n    mapping(address => UserRole) public userRoles;\n    mapping(uint256 => Property) public properties;\n    mapping(uint256 => TransferRequest) public transferRequests;\n    mapping(uint256 => OwnershipHistory[]) public ownershipHistory;\n    mapping(address => uint256[]) public userProperties;\n    \n    uint256 public propertyCounter;\n    uint256 public transferCounter;\n    \n    address public admin;\n    \n    // Events\n    event PropertyRegistered(\n        uint256 indexed propertyId,\n        address indexed owner,\n        string propertyAddress,\n        string ipfsHash\n    );\n    \n    event TransferInitiated(\n        uint256 indexed transferId,\n        uint256 indexed propertyId,\n        address indexed seller,\n        address buyer\n    );\n    \n    event BrokerVerified(uint256 indexed transferId, address indexed broker);\n    event RegistrarVerified(uint256 indexed transferId);\n    event MunicipalApproved(uint256 indexed transferId);\n    event BuyerAccepted(uint256 indexed transferId);\n    event TransferCompleted(uint256 indexed transferId, uint256 indexed propertyId, address newOwner);\n    event TransferCancelled(uint256 indexed transferId);\n    event RoleAssigned(address indexed user, UserRole role);\n    \n    // Modifiers\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Only admin can perform this action\");\n        _;\n    }\n    \n    modifier onlyRole(UserRole role) {\n        require(userRoles[msg.sender] == role, \"Insufficient role permissions\");\n        _;\n    }\n    \n    modifier validProperty(uint256 _propertyId) {\n        require(properties[_propertyId].isActive, \"Property does not exist\");\n        _;\n    }\n    \n    modifier validTransfer(uint256 _transferId) {\n        require(transferRequests[_transferId].status != TransferStatus.Completed && \n                transferRequests[_transferId].status != TransferStatus.Cancelled, \n                \"Transfer already completed or cancelled\");\n        _;\n    }\n    \n    constructor() {\n        admin = msg.sender;\n        propertyCounter = 0;\n        transferCounter = 0;\n    }\n    \n    /**\n     * @dev Assign role to a user (only admin)\n     */\n    function assignRole(address _user, UserRole _role) external onlyAdmin {\n        require(_user != address(0), \"Invalid user address\");\n        userRoles[_user] = _role;\n        emit RoleAssigned(_user, _role);\n    }\n    \n    /**\n     * @dev Register a new property\n     */\n    function registerProperty(\n        address _owner,\n        string memory _propertyAddress,\n        string memory _propertyType,\n        uint256 _area,\n        string memory _ipfsHash\n    ) external onlyRole(UserRole.Registrar) returns (uint256) {\n        require(_owner != address(0), \"Invalid owner address\");\n        require(bytes(_propertyAddress).length > 0, \"Property address required\");\n        require(bytes(_ipfsHash).length > 0, \"IPFS hash required\");\n        \n        propertyCounter++;\n        \n        properties[propertyCounter] = Property({\n            propertyId: propertyCounter,\n            currentOwner: _owner,\n            propertyAddress: _propertyAddress,\n            propertyType: _propertyType,\n            area: _area,\n            ipfsHash: _ipfsHash,\n            registrationDate: block.timestamp,\n            isActive: true\n        });\n        \n        userProperties[_owner].push(propertyCounter);\n        \n        ownershipHistory[propertyId].push(OwnershipHistory({\n            owner: _owner,\n            transferId: 0,\n            timestamp: block.timestamp,\n            ipfsHash: _ipfsHash\n        }));\n        \n        emit PropertyRegistered(propertyCounter, _owner, _propertyAddress, _ipfsHash);\n        \n        return propertyCounter;\n    }\n    \n    /**\n     * @dev Seller initiates a property transfer\n     */\n    function initiateTransfer(\n        uint256 _propertyId,\n        address _buyer,\n        uint256 _price,\n        address _broker,\n        string memory _documentsHash\n    ) external validProperty(_propertyId) returns (uint256) {\n        require(properties[_propertyId].currentOwner == msg.sender, \"Only owner can initiate transfer\");\n        require(userRoles[msg.sender] == UserRole.Seller || properties[_propertyId].currentOwner == msg.sender, \n                \"Must be seller or property owner\");\n        require(_buyer != address(0), \"Invalid buyer address\");\n        require(_buyer != msg.sender, \"Buyer cannot be seller\");\n        require(_price > 0, \"Price must be greater than zero\");\n        require(bytes(_documentsHash).length > 0, \"Documents hash required\");\n        \n        transferCounter++;\n        \n        transferRequests[transferCounter] = TransferRequest({\n            transferId: transferCounter,\n            propertyId: _propertyId,\n            seller: msg.sender,\n            buyer: _buyer,\n            price: _price,\n            documentsHash: _documentsHash,\n            status: TransferStatus.Initiated,\n            broker: _broker,\n            brokerVerified: false,\n            registrarVerified: false,\n            municipalApproved: false,\n            buyerAccepted: false,\n            createdAt: block.timestamp,\n            completedAt: 0\n        });\n        \n        emit TransferInitiated(transferCounter, _propertyId, msg.sender, _buyer);\n        \n        return transferCounter;\n    }\n    \n    /**\n     * @dev Broker verifies the transaction\n     */\n    function brokerVerify(uint256 _transferId) external validTransfer(_transferId) {\n        require(userRoles[msg.sender] == UserRole.Broker, \"Only broker can verify\");\n        require(transferRequests[_transferId].broker == msg.sender, \"Unauthorized broker\");\n        require(transferRequests[_transferId].status == TransferStatus.Initiated, \n                \"Transfer not in Initiated status\");\n        \n        transferRequests[_transferId].brokerVerified = true;\n        transferRequests[_transferId].status = TransferStatus.BrokerVerified;\n        \n        emit BrokerVerified(_transferId, msg.sender);\n    }\n    \n    /**\n     * @dev Registrar verifies documents and ownership\n     */\n    function registrarVerify(uint256 _transferId) external validTransfer(_transferId) \n        onlyRole(UserRole.Registrar) {\n        require(transferRequests[_transferId].status == TransferStatus.BrokerVerified, \n                \"Broker verification required first\");\n        \n        transferRequests[_transferId].registrarVerified = true;\n        transferRequests[_transferId].status = TransferStatus.RegistrarVerified;\n        \n        emit RegistrarVerified(_transferId);\n    }\n    \n    /**\n     * @dev Municipal office approves the transfer\n     */\n    function municipalApprove(uint256 _transferId) external validTransfer(_transferId) \n        onlyRole(UserRole.Municipal) {\n        require(transferRequests[_transferId].status == TransferStatus.RegistrarVerified, \n                \"Registrar verification required first\");\n        \n        transferRequests[_transferId].municipalApproved = true;\n        transferRequests[_transferId].status = TransferStatus.MunicipalApproved;\n        \n        emit MunicipalApproved(_transferId);\n    }\n    \n    /**\n     * @dev Buyer accepts the transfer\n     */\n    function buyerAccept(uint256 _transferId) external validTransfer(_transferId) {\n        require(msg.sender == transferRequests[_transferId].buyer, \"Only buyer can accept\");\n        require(transferRequests[_transferId].status == TransferStatus.MunicipalApproved, \n                \"Municipal approval required first\");\n        \n        transferRequests[_transferId].buyerAccepted = true;\n        transferRequests[_transferId].status = TransferStatus.BuyerAccepted;\n        \n        emit BuyerAccepted(_transferId);\n        \n        // Automatically complete transfer after buyer acceptance\n        completeTransfer(_transferId);\n    }\n    \n    /**\n     * @dev Complete the transfer (internal function called after buyer acceptance)\n     */\n    function completeTransfer(uint256 _transferId) internal {\n        TransferRequest storage transfer = transferRequests[_transferId];\n        require(transfer.status == TransferStatus.BuyerAccepted, \"Buyer acceptance required\");\n        \n        uint256 propertyId = transfer.propertyId;\n        Property storage property = properties[propertyId];\n        \n        // Update property ownership\n        address oldOwner = property.currentOwner;\n        property.currentOwner = transfer.buyer;\n        property.ipfsHash = transfer.documentsHash;\n        \n        // Update ownership history\n        ownershipHistory[propertyId].push(OwnershipHistory({\n            owner: transfer.buyer,\n            transferId: _transferId,\n            timestamp: block.timestamp,\n            ipfsHash: transfer.documentsHash\n        }));\n        \n        // Update user properties\n        userProperties[transfer.buyer].push(propertyId);\n        \n        // Update transfer status\n        transfer.status = TransferStatus.Completed;\n        transfer.completedAt = block.timestamp;\n        \n        emit TransferCompleted(_transferId, propertyId, transfer.buyer);\n    }\n    \n    /**\n     * @dev Cancel a transfer (only seller or admin can cancel)\n     */\n    function cancelTransfer(uint256 _transferId) external validTransfer(_transferId) {\n        require(msg.sender == transferRequests[_transferId].seller || msg.sender == admin, \n                \"Only seller or admin can cancel\");\n        \n        transferRequests[_transferId].status = TransferStatus.Cancelled;\n        \n        emit TransferCancelled(_transferId);\n    }\n    \n    /**\n     * @dev Get property details\n     */\n    function getProperty(uint256 _propertyId) external view returns (\n        uint256 propertyId,\n        address currentOwner,\n        string memory propertyAddress,\n        string memory propertyType,\n        uint256 area,\n        string memory ipfsHash,\n        uint256 registrationDate,\n        bool isActive\n    ) {\n        Property memory property = properties[_propertyId];\n        return (\n            property.propertyId,\n            property.currentOwner,\n            property.propertyAddress,\n            property.propertyType,\n            property.area,\n            property.ipfsHash,\n            property.registrationDate,\n            property.isActive\n        );\n    }\n    \n    /**\n     * @dev Get transfer request details\n     */\n    function getTransferRequest(uint256 _transferId) external view returns (\n        uint256 transferId,\n        uint256 propertyId,\n        address seller,\n        address buyer,\n        uint256 price,\n        string memory documentsHash,\n        TransferStatus status,\n        address broker,\n        bool brokerVerified,\n        bool registrarVerified,\n        bool municipalApproved,\n        bool buyerAccepted,\n        uint256 createdAt,\n        uint256 completedAt\n    ) {\n        TransferRequest memory transfer = transferRequests[_transferId];\n        return (\n            transfer.transferId,\n            transfer.propertyId,\n            transfer.seller,\n            transfer.buyer,\n            transfer.price,\n            transfer.documentsHash,\n            transfer.status,\n            transfer.broker,\n            transfer.brokerVerified,\n            transfer.registrarVerified,\n            transfer.municipalApproved,\n            transfer.buyerAccepted,\n            transfer.createdAt,\n            transfer.completedAt\n        );\n    }\n    \n    /**\n     * @dev Get ownership history for a property\n     */\n    function getOwnershipHistory(uint256 _propertyId) external view returns (\n        address[] memory owners,\n        uint256[] memory transferIds,\n        uint256[] memory timestamps,\n        string[] memory ipfsHashes\n    ) {\n        OwnershipHistory[] memory history = ownershipHistory[_propertyId];\n        uint256 length = history.length;\n        \n        owners = new address[](length);\n        transferIds = new uint256[](length);\n        timestamps = new uint256[](length);\n        ipfsHashes = new string[](length);\n        \n        for (uint256 i = 0; i < length; i++) {\n            owners[i] = history[i].owner;\n            transferIds[i] = history[i].transferId;\n            timestamps[i] = history[i].timestamp;\n            ipfsHashes[i] = history[i].ipfsHash;\n        }\n        \n        return (owners, transferIds, timestamps, ipfsHashes);\n    }\n    \n    /**\n     * @dev Get properties owned by a user\n     */\n    function getUserProperties(address _user) external view returns (uint256[] memory) {\n        return userProperties[_user];\n    }\n}\n"
    }
  }
}

